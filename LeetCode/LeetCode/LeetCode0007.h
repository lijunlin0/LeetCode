#pragma once

/*
名称：整数反转

描述：给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。

解题思路：循环取模后反转，由于题目要求只能存储32位以下的整数，所以不能用long类型存储，而有些合法整数反转后就会超出范围，
         所以每次循环都应该判断，因为32位整数的范围为-2147483647到2147483647，所以我们应该在1/10处就开始判断，
         例如2147483651，它的十位（5）已经比范围最大值（4）大了，所以后面跟哪个数都会超出范围，
         所以，我们到【最大数的1/10】时，就要开始判断了
         如果某个数字大于 214748364那后面就不用再判断了，肯定溢出了。
         如果某个数字等于 214748364呢，需要要跟最大数的末尾数字比较，如果这个数字比7还大，说明溢出了。
*/

#include<iostream>

class LeetCode0007 {
public:
    int reverse(int x) {
        //反转后的整数+

        int res = 0;
        while (x != 0)
        {
            //末尾数
            int temp = x % 10;
            if (res > 214748364 || res == -214748364 && temp > 7)
            {
                return 0;
            }
            //判断是否 小于 最小32位整数
            if (res < -214748364 || res == -214748364 && temp>7)
            {
                return 0;
            }
            res = res * 10 + temp;
            x /= 10;
        }
        return res;
    }

    void test()
    {
        std::cout << reverse(1463847412);
    }
};